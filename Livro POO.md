#                   Livro Orienta√ß√£o a Objetos üë©üèΩ‚ÄçüöÄ

‚Äã                       ![](https://media2.giphy.com/media/AQRapWCgC7dThyVEYb/giphy.gif?cid=ecf05e47g71icdsmvdpj9c17vielqtj02m9v3sr8z0qoiikm&rid=giphy.gif&ct=g)

####                                                                                              

####  O livro pode ser encontrado [aqui.](https://www.casadocodigo.com.br/products/livro-oo-conceitos)

#### Cap√≠tulo 2 : Uma breve hist√≥ria da Orienta√ß√£o a Objetos: üìö

- #### A orienta√ß√£o a objetos nasce na d√©cada de 1960, na Noruega;

- #### O principal pioneiro para a Orienta√ß√£o a Objetos foi o conceito de *Simula√ß√£o*;

- #### Em POO, simula√ß√£o quer dizer simular eventos que ocorrem no dia a dia dentro da computa√ß√£o;

- #### Keith Tocher, em 1967 finaliza o conceito de simula√ß√£o e atrav√©s de modelos matem√°ticos, descreve como os computadores entendem a l√≥gica de simula√ß√£o dos eventos di√°rios;

-  #### A simula√ß√£o discreta usa eventos l√≥gicos e matem√°ticos para representar mudan√ßas do estado atrav√©s do tempo. A POO se deriva dela porque se preocupa com a mudan√ßa de estado, altera√ß√µes de informa√ß√µes ao longo do processamento. Aprecia a troca de informa√ß√µes para gerar informa√ß√µes.

- #### A primeira linguagem de programa√ß√£o orientada a objetos se chama *SIMULA 67*;

- #### SmallTalk-71 √© criada com o prop√≥sito de unificar a orienta√ß√£o a objetos para ser compilada em diferentes sistemas, j√° que as linguagens j√° existentes eram para uso do pr√≥prio sistema em que foram criadas;

### ü¶©O Paradigma de Programa√ß√£o Estruturada defende que √© poss√≠vel atrav√©s de 3 estruturas b√°sicas, representar todo e qualquer processo do mundo real. S√£o eles:

1. #### *Sequ√™ncia:* O programa √© uma sequ√™ncia finita de passos. Deve ser executado linearmente, um comando ap√≥s o outro. Todos os passos devem ser feitos para programar o algoritmo desejado. 

2. #### *Decis√£o:* Um determinado conjunto de c√≥digo pode ou n√£o ser executado. √â necess√°rio testes l√≥gicos para a tomada de decis√£o. (IF/ELSE - SWITCH/CASE)

3. #### *Itera√ß√£o*: Uma determinada parte do c√≥digo pode ser executada uma quantidade finita de vezes, dentro de um looping. (FOREACH, DO-WHILE, WHILE, FOR, REPEAT-UNTIL)

#### 0Ô∏è‚É£Inicialmente, para problemas simples, pode-se acreditar que somentes estas 3 estruturas s√£o o suficiente para manter um programa. Mas quanto maior a complexidade do sistema, menos √∫til a programa√ß√£o sequencial se torna. 

#### 1Ô∏è‚É£Dentro da Orienta√ß√£o a Objetos temos o conceito de Reutiliza√ß√£o. Dessa forma, podemos criar trechos de c√≥digos universais que podem ser chamados e executar fun√ß√µes automaticamente. Isso evita a duplica√ß√£o de c√≥digo, deixa a estrutura mais limpa e organizada e evita falhas. Elimina a necessidade de importa√ß√µes de bibliotecas e torna o processo mais limpo.

#### 2Ô∏è‚É£O conceito de Coes√£o passa que uma unidade de c√≥digo somente deve executar fun√ß√µes e atividades e possuir informa√ß√µes relacionadas ao que ela se prop√µe a fazer. Isso quer dizer que n√£o deve se misturar responsabilidades e manter as obriga√ß√µes muito separadas e organizadas.

#### 3Ô∏è‚É£O conceito de Acoplamento √© o termo para quantificar os relacionamentos entre as unidades de c√≥digo, para que quando acopladas, possam executar o programa de forma precisa e eficiente. O acoplamento anda muito junto com a coes√£o. Com c√≥digos coesos podemos fazer acoplamentos mais eficientes, dividindo responsabilidades semelhantes.

# Introdu√ß√£o a Orienta√ß√£o a Objetos ü•∞

### Abstra√ß√£o:

#### Se d√° ao fato de termos um molde para qual podemos evoluir posteriormente. Exemplo √© uma f√°brica de cadeira, onde temos o molde inicial e podemos us√°-lo para fazermos diferentes cadeiras.

### Reutiliza√ß√£o:

#### Conseguimos deixar o programa mais limpo atrav√©s de reutiliza√ß√£o de c√≥digos. Isso pode ser feito atrav√©s de heran√ßas, onde herdamos comportamentos de classes dentro de outras para a n√£o repeti√ß√£o de c√≥digos. Associa√ß√£o √© quando uma classe utiliza partes de outra classe. Essa troca evita repeti√ß√µes desnecess√°rias.

### Encapsulamento:

#### Quando precisamos apenas de resultados com f√≥rmulas complexas j√° prontas. Tamb√©m cria uma casca em volta do objeto, impedindo altera√ß√µes externas. 























